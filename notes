--------------------------------------------THINGS TO DO--------------------------------------------------------
 8TH
(DONE) 1) create basic express backend
(DONE) 2) create basic react frontend
(DONE) 3) make them talk to each other
-----------------------------------------------------------
8TH AND 9TH
1) create a user login system backend
    - set up connection to mongoDB (done)
    - set up user schema and authentication
(DONE) 2) create the react side of the login system
------------------------------------------------------------
9-10TH
1) create a blog writing backend system
2) create the React version of the blog backend
------------------------------------------------------------
10TH
1) backend for when visiting home page, shows all blog posts
2) react styling
-------------------------------------------------------------
11TH
1) basic user profile backend
2) basic user profile frontend
-------------------------------------------------------------
12TH
1) individual blog pages backend
2) individual blog pages frontend
-------------------------------------------------------------
12TH
1) Heroku




- so right now we are able going to version our api and in order to do that we are going to use the express Router
function. A router is a subset of routing.

ROUTER:
- a Router instance is a complete middleware and routing system; for this reason, it is referred to as a mini-app
- so basically when we use the router module it can be used in the same way that we can use app
- then we export that router and pass it into a route for our api.

-so when we use the app.use method, this is a form of the application middleware and when we specify the path
which is called mounting the path, that means that it will run for that path


-when we use the res.send(body) we are sending back an HTTP response

const port = process.env.PORT || 5000 means that we should use the whatever the environment variable PORT is or
5000 if there is nothing. this is used for when we are going to use Heroku.


REACT
- right now we are going to use the react router dom. This lets us create a single page application where we can
dynamically rewrite the current web page with new data from the web server instead of having to reload the entire
webpage. very bueno
- router allows our applicaiton to navigate between different components, changing the browser URL, modifying the browser
history and keeping the UI state in sync
<Router>: Keeps the UI in sync with the URL
<Link>: Renders a navigation link
<Route>: Renders a UI component depending on the URL

- so the main idea of the Router is to create a history object and this object lets us easily manage session
history anywhere Javascript runs. lets us manage the history stack, navigate and persist state between sessions

NESTED REACT ROUTER ROUTES:
-when a component is rendered by the router, threee porperties are passes as parameters:
1) match
2) location
3) history

- when there is a match between the router's path and the URL location, a match object is created with infromation
about the URL and the path, so there are properties on this object:
1) params: key/value pairs parsed from the URL corresponding to the parameters
2)isExact: true, if the entire URL was matched (no trailing characters)
3) path: the path pattern used to match
4) url: the matched portion of the URL

- so <Switch> is a router matcher like <Route>. When a Switch is rendered it searches through its children <Route />
elements to find one whose path matches the current URL. When it finds one it renders that <Route> and ignores all others
- if no <Route> is rendered than the <Switch> renders nothing

CALLING THE EXPRESS BACKEND
- so it looks like we just going to have to do some calling with the fetch API

fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise
that resolves to the Response to that request, whether it is sucessful or not. You can also optionally pass
in an init options as the second argument.
- by default the fetch API uses the GET method

- so I think I am going to use hooks for my server access and we are going to rely on the useEffect hook

USE EFFECT HOOK:
- this lets us preform side effect in functional components. Data fetching, setting up a subscription and manually
changing the DOM in React components are all examples of side effects. there are two types of effects, those
that require clean up and those that do not

- effects without clean up is code that runs after React has updated the DOM. things like Network requests, manual
DOM mutations, and logging are common examples of effects that don't require a clean up, we can say this becasue
we can run these actions and then forget about them.

- so we want to make a request to our server api and that means it would be a request without clean up becasue we
can run the code and then forget about it
- in normal React we would put these in componentDidMount and componentDidUpdate

- when we use the useEffect hook we are telling React that we need to do something after the render. we pass use
effect a function and REACT will call that function after performing the DOM updates.
-so for us we want to add the fetch call inside of the useEffect hook

- so when we are going to run our useEffect hook we are telling React that we want it to run the function that is passed
into the useEffect hook after the DOM is updated
- by defualt, effects run after every completed render, but you can choose to fire them only when certain values have
changed.

- ok so what we are going to build is an API server and then use a library to communicate to make requests to/from
the api dynamically

- so what we need to do is set up a connection to mongoDB with mongoose, create a user schema and then be able to
authenticate them.

- to handle HTTP POST requests in Express.js  we need to install the middleware called body-parser. it extracts
the entire body portion of an incoming request stream and exposes it on req.body.
- the body-parser module parses the JSON, buffer,string and URL encoded data submitted using HTTP POST
request

- we are going to connect MongoDB with express using mongoose. that is now DONE

SCHEMA:
-a mongoose schema is a configuration object for a mongoose model. a schemaTYpe is then a configuration object for
an individual property. A SchemaType says what type a given path should have, whether it has any getters/setters
and what values are valid for that path

so then once we have created our model


MAKING THE PASSWORD SAFE:
-to make sure our password is safe we are going to apply a one-way hash to it using the bcrypt algorithm
- Hashing is a one way function(a mapping). it's irreversible we apply the secure hash algorithm and you
cannot get the original string back. the most that we can do is to generate what is called a collision, that
is finding a different string that provides the same hash. Cryptographically secure hash algorithms are designed
to prevent the occurence of collisions
- so basically a hash is a one way where a string gets turned into a jumble of stuff and the only way we can
get a same answer is with a collision but good Hashing algorithms are made to avoid this
- you can attack a secure hash by using a rainbow table, which can be couteract by applying a salt to the hash
before storing it
- a salt is random data that is used as additional input to a one-way function

- so we put in this confusing code for hashing the password and add it to the pre methods on the schema so that
it runs every time it a user is created.
- then we have to write code to compare the real password to a password guess. When a user logs in, we will need
to make sure the password they typed is correct.

- we use the genSalt(rounds, callback ) which is a function that will be used to salt the data, for ours we
put 10 and that is actually the default. we also give it a callback which will be fired when the salt
has been generated. the callback will recieve an error and result variable. if there is an error then we return
the error
- when the genSalt function gets ran it gets called with the rounds and callback, the callback gets and error
and the result, the result is the generated salt
- if there is no error then we run the hash function will run. the hash function, is given data,salt, progress
callback
- the data is the password to be encrypted, the salt is the from the last callback which is the generated salt
- the progress is a callback to be called during the hash calculation to signify progress. this is the noop
function which is the function expression that is assigned to the variable noop()
- it also gets a callback function to be fired once the data has been encrypted, the callback is called with
two parameters. the first is an error that will detail any errors and the second is the result, this will
provide the encrypted form of the data

- then after the encryption is done we have to create a function that compares the password entered with the
password that is in the database. this will be done with the bcrypt function called compare.
- the compare function gets called with data, encrypted and a callback function. The data parameter is the
data to be compared to the encrypted data.
- encrypted is the encrypted data to compare. the callback function will be fired once the data has been compared
and it takes an error and result parameter. the result is a boolean value to determine if the data and the
encrypted data are matching

-so in theory our database User Schema should be working
- so now we are creating the actual signup route with passport


- Ya I dont really know what is going to happen but I will try

- so to test that everything is working I need to make a post request to '/v1/signup' and the body on that request needs
to have a password and a username
- so lets just do a quick read up on the request body.

-the request object represents the HTTP request and has properties for the request query string, parameters, body
HTTP headers, and so on
- the request body contains key-value pairs of data submitted in the request body. by default it is undefined
and is populated when we use body-parsing middleware

- so I seem to be having troubles with the basic routing.Routing refers to how an application responds to
a client request to a particular endpoint, which is a URL and a specific HTTP request method (GET,POST, and so on)

- so right now I am going to create some vailidation for the form on the front end

REACT FORM VALIDATION:

- forms have two main types of event handlers
1) onSubmit
2) onChange
- since every form has these event handlers, we should be able to write a custom React Hook to handle these
events

- a custom Hook is a Javascrip tfunciton whose name starts with 'use' and that may call other hooks

- for every change in state we want to run our validation function we can simply create field value varibles
with useState() and then we pass those values into the useEffect dependency array so that it only runs when
those values change

- the first thing we need to do is store all the form state in out custom hook
- we need to get those valued from the forms first
- I really need to read up on the regular expressions

REGULAR EXPRESSIONS:
  - so I think that my regular expression would go something like this /[^a-zA-Z][0-9]$/



THE VALIDATION HOOK:
  -we create the a custom hook to do validation.
  - so the premise is pretty easy actually simple. we just want to validate the information that we put in and have the errors
  be returned.
  - so we create our own hook and call it useForm and then we create the states, we need states for the inputs, this will make
  the component controlled and this will give us access to the values that are put into the inputs of the from.
  - we have useState and we create an object out of it and call that object values, that object will have properties that are
  the values that we want for our schema.
  - we also create an object for the errors and have errors object mirrors the values that are in the other object.

  - so that seems pretty straight forword instead of creating individual values for the states we can make them alot cleaner and
  turn them into an object. the same goes with the errors. So when creating a custom hook for validation we should create a
  object that has properties that correlate to the values that are in our form. so if we have a form that has inputs like
  date,name,age and lastname. We would use the useState to create a values object that has the properties of date, name, age and
  lastname. Then we would use another useState hook to create an error state and that would mirror the properties that are
  on the other useState function.
  -then we create the most important funciton that we have when creating a form, that is the function that is called when the
  onChange method is called. We create the handleChange funtion, the only parameter is takes is one and it is the event.
  - inside that function we then use object destructoring to pull the name and value from the target and then we call the
  setValue funciton. setValue({...value,[name]:value}) this will use the spread operator to make sure we add the new name and
  value to the state and not completly delete the old state. We will add the [name]:value to the value object, the so the name will
  be what we have set for that current input, make sure that the name value is the same as the property name in the value object
  the value will be what is typed in the input.
  - so we will create somethign like this

            const handleChange = (event)=>{
              const{name,value} = event.target
              setValues({...values,[name]:value})
            }
  - the creation of the handleChange function will make the inputs a controlled component and that is needed for React forms

  - so then we have the handleSubmit function, this will get ran everytime that a form is submitted. the first thing that we
  need to do on this function is to call preventDefault(), this will prevent the form from automatically submitting
  - then we call the serError hook, this is the one that we created right after the values hook. so we call set error, but
  we give it a function as a parameter and that funciton is given the values object.
  - the function that we give the setErrors function is called validate login, the premise of that is pretty simple too, all
  it does is return an object that will contain the errors that we have and that object is then used with the call of setErrors
  - the validateLogin function is defined seperatly in a different file to promote an module code base. it takes a parameter
  called value and that is actually just the values object that we have created in our custom hook. So the parameter object
  will be value and that value will contain properties that are the values from the inputs that are on the form.
  - in the validateLogin we check all those properties on the value object to see if they meet our standard. if they do not then
  we add to the error object that will be returned.
  -so if the values.password is less than 10 characters in length it we will add to the error.password:'password too short'
  and that will be in the returned error object. We do this for every property that is added on the values object.
  - so that should be everything, then on the customHook called Useform we return, the values object, the errors object and the
  handleChange and handleSubmit function.


CREATING THE CUSTOM HOOK:
  - we have created the values and error hooks, then we need to create the handleChange and handleSubmit functions
  - when we create the handleChange funciton we need to make sure that the name we get is the same as the name that we
  have put in the value object.
  - then we call the setValue function and use the spread operator to make sure we dont overwrite the old vlaues.
      setValues({...values,[name]:value})
  - so I think that is everything for the handleChagne function, we can then move on to the handleSubmit function and we pass it two
  parameters, the parameters will be event and a function called validate login. we will use event to prevent the default action
  -we will use the validateLogin function and pass it into the setErrors hook, the validate funciton will be called with the values
  obect and return an errors object. This errors object will be used by setErrors to update the errors object.
  - we have created all of the checks that we are going to run, if any of them fail, they will add to the errors object that will
  be returned from the ValidateLogin function and used by the setErrors function.

  - so now that the custom hook is created we import it to the form component
  - we import it to the component and use obejct destructoring from the funciton that is ran with the parameter of validate function
  - we get the values,errors, handleChange and handleSubmit. the values will be put in the value place of the input so we can
  have a controlled input.
  - the errors object will be put under the respected inputs, if there is no errror than nothing will show. handleChange and
  handleSubmit will be put in their respected positions

  - now we are adding a stage called is submitting
  - this is done with the useEffect hook, through this we are checking to see if the errors object is empty, if it
  is then we are going to rend the request, if it is not, then we are going to do nothing.

  - so the first thing that we are going to do for the submitting stage is create a state called is submitting and set
  the inital value to false but when the handleSubmit function is called we change the value to true.
  - then we use the useEffect hook. we will put the errors object in its dependency array this means that it will get called
  any time that the errors object gets called. Initialy we will have the error object empty with no properties.
  - to check to see if the errors object is empyt we will use Object.keys(errors).length, this will strip all of
  the keys off the object and put them into an array, if there are no keys, then the length will be 0.
  - we want the errors array to be zero so that we can send a request to the backend.
  - we made the errors object initial empty this is ok, because the validatLogin funciton will repopulate the object if there
  is any errors.

  - so the first thing that we do is import the useEffect hook, then we turn the errors object to an empty object, initialy
  - then we use the useEffect hook and put the errors object in the dependency arrray. The next step is to create a new state
  called is submitting and set the inital value to false, this will get turned to true when we fire the handleSubmit function

  - in the useEffect function we need to check if the errors object is empty, we will do this by doing
  Object.keys(errors).length === 0 this will see if the errors object is empty or not, the we will also check is isSubmitting
  is false or true, we want it to be true, this will just be done with a && operator, the the whole thing will work like this
          Object.keys(errors).length ===0 && isSubmitting{
            sendRequest()
          }
 - so this is checking to see if the errors object is empty and if isSubmitting set to True. If both of these conditions are met
 then we will send the request to the backend. in our program this will be a fetch request. For right now we are going to only send
 the userName and the password.

SENDING THE POST REQUEST:
  - so this has me a little confused but I am just going to send a post request with fetch and see what happens.
  - The post request needs to be to v1/signup. so that means we make the fetch call to that endpoint

  - A Requets instance represents the request piece of fetch call. By passing fetch a
  - the bodyParser object exposes various factories to create middlewares. All middlewares will polute the req.body
  property with the parsed body when the Content-Type request header matches the type option, or an empty object
  if there is no body to parse, the Content-type was not matched or an error occured.
  - so my body is empty that means that I could have one of three problems, there is no body to parse, the
  Content-Type was not matched or an error occured
  - I think my problem is probably the content-type in the request header

  bodyParser.json([options]) returns middleware that only parses json and looks at the requests where the content-Type header
  matches the type option.
  - a new body object containing the parsed data is populated on the request object after the middleware
  (ie, req.body)

  bodyParser.urlencoded([options])
  - Returns middleware that only parses urlencoded bodies and only looks at requests where the Content-Type header
  matches the type option. This parser accepts only UTF-8 encoding of the body and supports automatic inflation of
  gzip and deflate encodings
  - a new body object containing the parsed data is populated on the request object after the middleware
  req.body. This object will contain key-value pairs, where the value can be a string or array
  when extended is false, or any type (when extended is true).
  - our extended is set to true so which means that the req.body can be of any type.
  - so I need to read up on the content-type header

  CONTENT-TYPE HEADER:
    -is used to indicate the media type of the resource.
    - in requests like a post, the client tells the server what type of data is actually sent. I think for our
    body-parser we need to set the content-type header to, Content-Type:text/html; charset=UTF-8

    - by default Axios serializes the object to JSON using the JSON.stringify() funciton, if the second
    parameter is an object, then axios also sets the content-type header to applciation/json
    - I have decieded to read more on the API stuff

  EXPRESS API:
  - the fundamentals of an express api are pretty basic, they take a request, parse it and respond
  with a JSON object and an HTTP status code. we will use middleware and routing to take requests and parse
  them, and youll use Express's convience to respond to requests
  - so we will use middleware to parse the incoming data and then we will use express to make the response
  to the request
  -so I finally fixed it, turns out that axios automatically puts everything into a json content header and
  we just have to set the bodyParser to JSON like this bodyParser.json() this will allow us to accept axios's
  JSON data.

  - so the dependency array is yelling at me for not having the right things inside of it. so lets read up on that

  USEEFFECT API:
    - if we use the array optimization, we should make sure that it includes all the values from the component
    scope(such as props and state) that change over time and that are used by the effect. if we don't include
    everything in the dependency array then we will be referencing stale values from previous renders.


MONGOOSE:
  - we can use a low-level friver fro MongoDB but what we really want to use is an object document mapper (ODM).
  the offically supported ODM for MongoDB is mongoose
  - mongoose attempts to strike a balance. it introduces schemas and models, it is what will give our database some
  structure.
  - the mongoose findOne function returns an instance of Mongoose's query class. The query class represents a raw CRUD
  operation that you may send to MongoDB. it provides a chainable interface for building up more sophisticated
  queries
  - a mongoose query is a thenable, meaning that they can have a then() funciton. this means that we can use the
  .then() and the catch() method. so we can go Model.find().then().catch()

STORING THE PASSWORD:
  - so to keep the passwords safe, we will apply a one-way hash to it using the brypt algorithm
  - once we have defined our schema, we will define a pre-save action. Before we save our model to the database
  we will run that code and it will hash the password
  - ok so I think I have everything set up, now the only thing I have to do is run the function to see if it works

  - I have ran into an error where nothing is working, I think that It is happening due to something on the
  client end. that was weird because now everything is working again. very strange.

  - so now that we have that figured out we should be able to just submit the data and see what happens. I forgot
  that I needed to call .save on the new model

  -our new problem is that the request gets sent but there is no response
  - ok so we are getting a duplication key error message,
  - I think that the problem lies with the fact that what I using a async request
  - so I need to look at the

ASYNC PROGRMMING:
  - do to javascript single thread nature, only one thing can happen at a time. we can get around this blocking
  by using asynchronous code, this can be done with callbacks and new promises.
  callbacks:
    -these are functions that are specified as arguments when calling a function which will start executing code
    in the background. when the background code finishes running, it cals the callback function to let us know
    that the work is done.
    - so a callback will be used when we have a async action and then have a function that will be fired once that
    action is done.
    - when we pass a callback function as an argument to another function we are only passing the fucntion's reference
    as an argument, this just means that the function is not called immediately
    - it should be noted that not all functions are asny

  promises:
    -a promise is an object that represents the completion or failure of the async operation.
    - the then() blocks contain a callback function that will run if the previous operation is successful.
    - each then() block recieves that input from the previous one, each then() returns another promise.
    - this is what allows us to chain multiple then blocks
    - the catch() block runs if any of the .then() blocks fail

  The event queue:
    - async operations like promises are put into an event queue, which runs after the main thread has finished
    processing. the queued operations will complete as soon as possible then return their results to the
    Javacsript enviroment

ASYNC AND AWAIT:
  -the async keyword, is put infron of a function declaration to turn a function into an async function.
  - An async function is on that expects the posibility of the await keyword which will invoke asynchronous code
  - this will mean that invoking the function noew returns a promise
  -to actually consume the value returned when the promise fullfills we can sue the .then() blocks
  - the async keyword is added to funcitons to tell them to return a promise rather than direcly returning a value
  await:
    -await only works inside async functions. this can be put infront of any async function to pause the code
    on that line until the promsie fullfills, then reutrn the resulting value
    - we can use await when calling any function that returns a Promsie. including Web API funcitons

- so the async bug was actually just created by me trying to make things more clever than they need to be
- to fix it I just simplified things by deleting a bunch of code.


PASSPORT:
  - passport is authentication middlware for Node. it is designed to serve a singular purpose, authenticate requests
  authentication:
    -authentication refers to verifying a users' identities. That is they are who they sau they are
  authorization:
    -authorization refers to determining what a user is authorized to access, modify or view

  - usually authentication comes first and then authorization is determined
  - so passport is used for robust authentication module for NODE/ EXpress
  - passport is for authentication and authentication is checking to see who the user is.
  - passport is base on the idea on authentication strategies, including a local stragegy if we don't want
  to use a third party which right now we don't
  - with third party authentication, our app never recieves a password
  - when we use passport, our app is responsible for 4 things
  - passport is designed to serve a singular purpost:authenticate requests. so basically we drop in passport write a
  little bit of code to wire up the routes and we will be ok
  - passport doesnt dicate how to authenticate users, it only provides helpful boilerplate code, we could use
  passport to sign into google and twitter, facebook and more third party happens
  - when setting up Passport, we need to do three things
  1) set up the Passport middleware:
  2) Tell Passport how to serialize and deserialize users:
  3) Tell Passport how to authenticate users:

  - so we need to isntall the middleware, tell it how to serialize and deserialize users and how to authenticate
  users
  - to initialize Passport we will need to set up three officail Express middlewares, a third party middleware and
  then two Passport middlewares
  1) body-parsers: parses HTML forms
  2) cookie-parser: handles the parsing of cookies from browsers and is required for user sessions
  3) express-session: stores user sessions across different browsers
  4) connect-flash: shows error messages
  4) passport.initialize: initialize the Passport module
  5) passport.session: Handles Passport sessions

  SESSION SECRET:
    -this secret is a key that is used for signing and/ or encrypting cookies set by the application to
    maintain session state
    - in practice this is often what prevents users from pretending to be someone they're not.
    -cookies are the most common way for web applciations to persist state(like the current logged in user )
    across distinct HTTP requests.
    - well alot of bad things can be done with an easy session secret but I am just going to use the one that
    is infront of me for right now

- there are 3 options that we pass to express-session
1)secret: allows each session to be encrypted from the client. this deters hackers from hacking into users
cookies, as noted we should use a secure bunch of randomly genreated stuff but we have not

2)resave: is an option that is required by middleware. when it is set to true, the session will be updated
even when it hasnt been modified

3)saveUnitialized: is another requried option. this resets sessions that are unitialized

-so when we are using express sessions we need to set the secret, resave which when set to true will be
updated even when it hasn't been modified, idk what that means and we set the saveUnitialized to true
this will reset session that are unitialized


SERIALIZATION AND DESERIALATION:
  -passport needs to know how to serialize and deserialize users. In other words we need to translare a
  user's session into an actual user object and vice-versa

  - in a typical we application, the credentails used to authenticate a user will only be transmitted during
  the login request. If authentication succeeds, a session will be established and maintained via a cookie
  in the user's browser

  - each subsequent request will not contain credentials, but rather the unique cookie that identifies the
  the session. In order ro support login sessions, Passport will serialize and deserialize user instances
  to and from the session.

  - credentials used to authenticate the user will only be sent during the login process.If that succeds then
  we will get a cookie in the users browser
  - then each request that follows will not have a the users info, just the cookie instead, this cookie will
  be used to identify the session. Passport will then need to serialize and deserialize user instances to and
  from the session.
  -so we will need to translate a user's session into an actual user object and vice-versa

  -because our user models have a unique _id property, we will use that as our translation



PASSPORT:
  - so when we make a post request to the login endpoint of our url we are going to run passport.authenticate and
  with that we are going to use the local stragety that we defined in the passport folder

  - so when we are using passport we first need to define a stragety for passport. the way that we define this
  stragety is with passport.use() and then we define the stragety in the method

  -so since passport is automatically setup to recieve a template engine, we have to create a custom callback to
  create a custom callback to work around that. When we run passport.authenticate, what we have to do is pass
  authenticate a custom callback that will return json data based on the response from the server.

  authenticate:
    -authenticating requests is as simple as calling passport.authenticate() and specifying what stragety
    to employ. the info argument is optional and it will contain additional details provided by the stragety's
    verifying callback

  strategies:
    - passport uses what are termed strageties to authenticate requests. Strageties range from verifying a username
    and password, delegated authentication using OAuth or federated authentication using OpenID
    - before we use passport.authenticate, we must set up a stragety
    - strategies, and their configuration, are supplied via the use() function.
    - when using the custom callback, if it fails to authenticate, then the user will be set to false.
    -at the current moment I do not have a verify callbakc because the main purpose of one is to find the user
    that possesses a set of credentails.

  Verify Callback:
    - strategies require what is know as a verifying callback. The purpose of a varify callback is to find the user
    that possesses a set of credentials
    - when passport authenticates a request, it patses the credentials contained in the request. it then invokes the
    verify callback with those credentials as arguments. If the credentials are valid, the verify callback invokes
    done to supply passport with the user that authenticated.

    - so every stragety must have a verifying callback, the whole point of this thing to is find a user that
    possesses a set of credentials.
    -when passport authenticates a request is parses the credentials that are in the request and then it incokes the
    verufying callback with those credentials as arguments. so pretty much passport will grab those credentials
    and then run the verifying callback, wich will try to find the user that possess those credialtials.
    - if the credentials are valid, the verifying callback invokes done and supply Passport with the user that
    authenticated.
    - so done only gets called if the user was found


    - so passport.authenticate is specifying which strategy to employ. so when we see the passport.authenticate(),
    it is telling passport what stragety to employ

    -if authentication fails, passport will respond with 401 Unauthorized status, and any additional route
    handlers will not be called

    - strageties will have to be defined before they are used with the passport.authenticate() function

    configure:
      - there are three  piecies that need to be configured to use Passport for authentication
        1): Authentication strategies
        2): Application middleware
        3): Sessions(optional)

    - strategies are used to authenticate requests. we can create and configure a stragetie inside of the use()
    function.
    - strageties require what is called a verify callback and that callback is used to find the user that
    possesses a set of credentials
    - when Passport authenticates a request, it parses the redentials contained in the request. it then invokes the
    verify callback with those credentials as arguments.
    - so basically when the passport.authenticate() is ran it will look for what stragety is used, then go into
    that stragety and parses the credentials in the request, it then calls the verify callback with the credentials
    and the point of the verify callback is to find a user with certain credentials.
    - if the credentials are valid, the verify callback invokes done to supply Passport with the user that
    authenticated
    - so passport.authenticate gets called and then it looks for the stragety that was defined with the
    passport.use funciton and the credentails get parsed and then the verify callback is used to identify
    if there is a user with those credentials, if the user is found, then the done function is called with the
    authenticated user.

    -if credentials are valid we call the done function with null and user:done(null,user),

    - don is an internal PassportJS function, we pass it two arguments

    - so what I need to do is figure out what done is sending and how to handle what it is sending when we
    have no user
    -ok so when we call the done function in our stragety we are giving it three arguments, error, user and
    info which is an object and it can contain any aditional information

    - so for use this is what is currently happening, we are going to do the following
    1) call passport.authenticate('login'callbackFunc)
    2)go into the pre-specified stragety that we defined with the use() method and called login. THis function
    will parse the user and password automatically from the request.
    3) call the verify callback in the stragety. this will use a findOne({}) function to see if the user with
    the credentials is actually there, we also give findOne({},callbackFunc(err,user)) a callback function that will run
    with either a error message or a user object if the user was authenticated.
    4) based on what is returned we then run the done(err,user,{})method with a error object, the authrnticated user
    or a message object, which can be filled with anything.
    5) what is returned from the done function is then given to the callback function in user.passport


RESPONSE:
  - reposne object represent the Http response that an express app sends when it get an HTTP request.
  -so when we send an HTTP request object we expect to get an HTTP response object.
  - express will automatically append the COntent-Type and the COntent-length headers for the response
  - so res.send and res.json are the same, thing one just sends plain text and the other sends json, they
  both send data and end the response.


- So i need to figure out what is happening when  I try to submit a user.

CREATING A USER WHERE THE USERNAME ALREADY EXISTS:
  - so when we send a request to the signup route, we are going to get the username and password out of
  the request body. we will then run a findone query on the database to see if the user already exists or not
  if the user does not exist then we will create is with a new scema and save it.
  -if the username already exists then we should get back a user already exists message. so lets try that out
  - so that works

CREATING A NEW USER:
  - we ran into a bug here but I think that it will be easy to work out with a redirect, so we will deal with that
  later. the create user is working fine. Now we have to checkout if the login routes work


LOGIN A USER:
  -passport is authenticattion middleware for node. it is designed to serve a singular purpose:authenticate requests
  - when we set up passport we will need to do three things
  1) set up Passport middleware. This is easy
  2) tell passport how to serialize and deserialize users. THis is a short amount of code that effectvely
  translates a user's session into an actual user object. I think this is the session part that I am still a little
  confused about
  3) Tell Passport how to authenticate users.

SERIALIZATION AND DESERIALATION:
  -passport needs to know how to serialize and deserialize users. we will need to translare a user's session into
  an actual user object and vice-versa.
  - if authentication suceeds, a session will be established and maintined via a cookie set in the user's browser
  - then each request will not ontain credentials, but rather the unique cookie that identifies the session
  - in order to support login sessions, Passport will serialize and deserialize user instances to and from the
  session
  - to use the serialize and deserialize sessions we will have to call passport.serialize and passport.deserialize
  - if login(authentication) succeds a session will be established and maintained via a cookei set in the user's
  browser, so that means that this will have to happen after the stragety is performed by the passport.authenticate()

  - so bascially all this boils down to making requests to the backend and having an API respond in kind to the
  request that we have sent to it. Really not that hard when you think about it.

  - so we are making a request to the login endpoint with that values attached. that will then run the
  passport.authenticate middleware that we have on the endpoint, it will parse off the username and the password
  automatically and then run the verify callback to see if the user is in the database or not. Then depending
  of if there is a user or not and if the password matches or not, the done function will be run and the done method wil
  returnt he error object, the user object and the info object back to the function that is on the
  passport.authenticate middleware.

REDIRECTING WITH THE WITH THE REACT ROUTER DOM:
  - so it looks like we can just use the redirect component that react-router provides for us.
  - the real workhorse of React ROuter is the history library. Under the hook, it is what is keeping track
  of session history for React Router. When a component is rendered by React ROuter, that component is passed three
  different props, location,match and history. the history has a bunch of fanct properties on it but we are only
  going to use the hsitory.push().What it does is it pushes a new entry into the history stack, aka redirects the user
  to another route. so we would go props.history.push('/') this would redirect us to the home page

  - so the primary way we navigate in React ROuter is by using a <Redirect /> component
  - whenever somthign is rendered with React Router it is passed 3 props, location, history and match



  -serialize will add the user into passport as a session

EXPRESS SESSIONS:
  - HTTP is a stateless, in order to associate a request to any other request, we need a way to store user
  data between HTTP requests. Cookies and URL parameters are both suitable ways to transport between request.
  Cookies are URL parameters are both suitable ways to transportdata between the client and the server but both
  are readable and on the client side.
  - sessions solve this problem. we assign the client an ID and it makes all further requests using that ID. information
  associated with the client is stored ont he server linked to this ID
  - the session middleware handles all things for us. like creating the session, settin the session cookie and
  creating the session objct in req object.
  - when we make a request form the same client again, we will have their session infromation stored with us
  (assuming that the server was not restarted)
  - so we install cookie-parser and session
  - so what we want to happen is that we the user gets created we want a session to be created so that we can use
  that session to validate against and check the user.
  - so we have the session creation when the server is sent a request.
  - so what do we know so far? we know that HTTP is a stateless protocall so if we want to persist data we will have
  to use sessions
  - we want to store the users ID so that we can query the users ID to display different infromation about that user
  - the session is attached to the request, so you can access it using req.session
  - so we need to create a middleware that will be used for authenticating our users
  - lets do a quick review on what the heck middleware is, I think that are just function that can be used or routes
  or not and they recieve req,res,next
  middleware:
    - I was right, thats literaly what middleware is. They are functions that have access to the request and
    response objects and the next function. if it does not end the request, response cycle then it must call the
    next function.

  - now that I have a little better idea on what is happening with sessions, I think I need to better understand
  the serialize and deserialize process. Then I think I need to understand what we are doing with the sessions like when
  are we creating the IDs that will persist

DESERIALIZE AND SERIALIZE:
  - so it appears that the serialize and the deserialize may be the peeps behind the cookies.
  - so the user id that we provide the done function is saved in the session and later used to retirieve
  the whole objcet via the deserializeUser function.
  - the serializeUser determines which data of the user obecjt should be stored int he session. The result of
  the serializeUser determines which data of the user object should be stored int he session. The result
  of the serializeUser method is attached to the session as req.session.passport.user
  - so the serializeUser will add the nesessary data to the session object and the deserializeUser will remove
  it and use it to see if the user is authenticated or not

  - we are going to take an identifying piece of information from the user, which will be the user id and put that
  into a cookie and then that cookie will be used for authentication purposes
  - so the serializeUser will be the function that will take the info form the UserID and stuff it into a cookie
  - deserialize works the opposite way, it takes the id form the cookie and then checks to see if that user is in the data
  base and then authrnticates it

  - just to make thigns super clear, this is what is going to happen when the whole thing kicks off.  The serializeUser
  is what will put the users data into the session. so This is what passport is using to store the data inside of the session
  - that would mean that the deserialize will do the oposite, the whole user object will be retured thanks to the help
  of the id that it will get from the session

  - so when we log our user into the app we want to create a session for them. session can be thought of as
  non-permanent data storage 
