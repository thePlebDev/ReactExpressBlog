--------------------------------------------THINGS TO DO--------------------------------------------------------
 8TH
(DONE) 1) create basic express backend
(DONE) 2) create basic react frontend
(DONE) 3) make them talk to each other
-----------------------------------------------------------
8TH AND 9TH
1) create a user login system backend
    - set up connection to mongoDB (done)
    - set up user schema and authentication
(DONE) 2) create the react side of the login system
------------------------------------------------------------
9-10TH
1) create a blog writing backend system
2) create the React version of the blog backend
------------------------------------------------------------
10TH
1) backend for when visiting home page, shows all blog posts
2) react styling
-------------------------------------------------------------
11TH
1) basic user profile backend
2) basic user profile frontend
-------------------------------------------------------------
12TH
1) individual blog pages backend
2) individual blog pages frontend
-------------------------------------------------------------
12TH
1) Heroku




- so right now we are able going to version our api and in order to do that we are going to use the express Router
function. A router is a subset of routing.

ROUTER:
- a Router instance is a complete middleware and routing system; for this reason, it is referred to as a mini-app
- so basically when we use the router module it can be used in the same way that we can use app
- then we export that router and pass it into a route for our api.

-so when we use the app.use method, this is a form of the application middleware and when we specify the path
which is called mounting the path, that means that it will run for that path


-when we use the res.send(body) we are sending back an HTTP response

const port = process.env.PORT || 5000 means that we should use the whatever the environment variable PORT is or
5000 if there is nothing. this is used for when we are going to use Heroku.


REACT
- right now we are going to use the react router dom. This lets us create a single page application where we can
dynamically rewrite the current web page with new data from the web server instead of having to reload the entire
webpage. very bueno
- router allows our applicaiton to navigate between different components, changing the browser URL, modifying the browser
history and keeping the UI state in sync
<Router>: Keeps the UI in sync with the URL
<Link>: Renders a navigation link
<Route>: Renders a UI component depending on the URL

- so the main idea of the Router is to create a history object and this object lets us easily manage session
history anywhere Javascript runs. lets us manage the history stack, navigate and persist state between sessions

NESTED REACT ROUTER ROUTES:
-when a component is rendered by the router, threee porperties are passes as parameters:
1) match
2) location
3) history

- when there is a match between the router's path and the URL location, a match object is created with infromation
about the URL and the path, so there are properties on this object:
1) params: key/value pairs parsed from the URL corresponding to the parameters
2)isExact: true, if the entire URL was matched (no trailing characters)
3) path: the path pattern used to match
4) url: the matched portion of the URL

- so <Switch> is a router matcher like <Route>. When a Switch is rendered it searches through its children <Route />
elements to find one whose path matches the current URL. When it finds one it renders that <Route> and ignores all others
- if no <Route> is rendered than the <Switch> renders nothing

CALLING THE EXPRESS BACKEND
- so it looks like we just going to have to do some calling with the fetch API

fetch() method takes one mandatory argument, the path to the resource you want to fetch. It returns a Promise
that resolves to the Response to that request, whether it is sucessful or not. You can also optionally pass
in an init options as the second argument.
- by default the fetch API uses the GET method

- so I think I am going to use hooks for my server access and we are going to rely on the useEffect hook

USE EFFECT HOOK:
- this lets us preform side effect in functional components. Data fetching, setting up a subscription and manually
changing the DOM in React components are all examples of side effects. there are two types of effects, those
that require clean up and those that do not

- effects without clean up is code that runs after React has updated the DOM. things like Network requests, manual
DOM mutations, and logging are common examples of effects that don't require a clean up, we can say this becasue
we can run these actions and then forget about them.

- so we want to make a request to our server api and that means it would be a request without clean up becasue we
can run the code and then forget about it
- in normal React we would put these in componentDidMount and componentDidUpdate

- when we use the useEffect hook we are telling React that we need to do something after the render. we pass use
effect a function and REACT will call that function after performing the DOM updates.
-so for us we want to add the fetch call inside of the useEffect hook

- so when we are going to run our useEffect hook we are telling React that we want it to run the function that is passed
into the useEffect hook after the DOM is updated
- by defualt, effects run after every completed render, but you can choose to fire them only when certain values have
changed.

- ok so what we are going to build is an API server and then use a library to communicate to make requests to/from
the api dynamically

- so what we need to do is set up a connection to mongoDB with mongoose, create a user schema and then be able to
authenticate them.

- to handle HTTP POST requests in Express.js  we need to install the middleware called body-parser. it extracts
the entire body portion of an incoming request stream and exposes it on req.body.
- the body-parser module parses the JSON, buffer,string and URL encoded data submitted using HTTP POST
request

- we are going to connect MongoDB with express using mongoose. that is now DONE

SCHEMA:
-a mongoose schema is a configuration object for a mongoose model. a schemaTYpe is then a configuration object for
an individual property. A SchemaType says what type a given path should have, whether it has any getters/setters
and what values are valid for that path

so then once we have created our model


MAKING THE PASSWORD SAFE:
-to make sure our password is safe we are going to apply a one-way hash to it using the bcrypt algorithm
- Hashing is a one way function(a mapping). it's irreversible we apply the secure hash algorithm and you
cannot get the original string back. the most that we can do is to generate what is called a collision, that
is finding a different string that provides the same hash. Cryptographically secure hash algorithms are designed
to prevent the occurence of collisions
- so basically a hash is a one way where a string gets turned into a jumble of stuff and the only way we can
get a same answer is with a collision but good Hashing algorithms are made to avoid this
- you can attack a secure hash by using a rainbow table, which can be couteract by applying a salt to the hash
before storing it
- a salt is random data that is used as additional input to a one-way function

- so we put in this confusing code for hashing the password and add it to the pre methods on the schema so that
it runs every time it a user is created.
- then we have to write code to compare the real password to a password guess. When a user logs in, we will need
to make sure the password they typed is correct.

- we use the genSalt(rounds, callback ) which is a function that will be used to salt the data, for ours we
put 10 and that is actually the default. we also give it a callback which will be fired when the salt
has been generated. the callback will recieve an error and result variable. if there is an error then we return
the error
- when the genSalt function gets ran it gets called with the rounds and callback, the callback gets and error
and the result, the result is the generated salt
- if there is no error then we run the hash function will run. the hash function, is given data,salt, progress
callback
- the data is the password to be encrypted, the salt is the from the last callback which is the generated salt
- the progress is a callback to be called during the hash calculation to signify progress. this is the noop
function which is the function expression that is assigned to the variable noop()
- it also gets a callback function to be fired once the data has been encrypted, the callback is called with
two parameters. the first is an error that will detail any errors and the second is the result, this will
provide the encrypted form of the data

- then after the encryption is done we have to create a function that compares the password entered with the
password that is in the database. this will be done with the bcrypt function called compare.
- the compare function gets called with data, encrypted and a callback function. The data parameter is the
data to be compared to the encrypted data.
- encrypted is the encrypted data to compare. the callback function will be fired once the data has been compared
and it takes an error and result parameter. the result is a boolean value to determine if the data and the
encrypted data are matching

-so in theory our database User Schema should be working
- so now we are creating the actual signup route with passport


- Ya I dont really know what is going to happen but I will try

- so to test that everything is working I need to make a post request to '/v1/signup' and the body on that request needs
to have a password and a username
- so lets just do a quick read up on the request body.

-the request object represents the HTTP request and has properties for the request query string, parameters, body
HTTP headers, and so on
- the request body contains key-value pairs of data submitted in the request body. by default it is undefined
and is populated when we use body-parsing middleware

- so I seem to be having troubles with the basic routing.Routing refers to how an application responds to
a client request to a particular endpoint, which is a URL and a specific HTTP request method (GET,POST, and so on)

- so right now I am going to create some vailidation for the form on the front end

REACT FORM VALIDATION:

- forms have two main types of event handlers
1) onSubmit
2) onChange
- since every form has these event handlers, we should be able to write a custom React Hook to handle these
events

- a custom Hook is a Javascrip tfunciton whose name starts with 'use' and that may call other hooks

- for every change in state we want to run our validation function we can simply create field value varibles
with useState() and then we pass those values into the useEffect dependency array so that it only runs when
those values change

- the first thing we need to do is store all the form state in out custom hook
- we need to get those valued from the forms first
- I really need to read up on the regular expressions

REGULAR EXPRESSIONS:
  - so I think that my regular expression would go something like this /[^a-zA-Z][0-9]$/



THE VALIDATION HOOK:
  -we create the a custom hook to do validation.
  - so the premise is pretty easy actually simple. we just want to validate the information that we put in and have the errors
  be returned.
  - so we create our own hook and call it useForm and then we create the states, we need states for the inputs, this will make
  the component controlled and this will give us access to the values that are put into the inputs of the from.
  - we have useState and we create an object out of it and call that object values, that object will have properties that are
  the values that we want for our schema.
  - we also create an object for the errors and have errors object mirrors the values that are in the other object.

  - so that seems pretty straight forword instead of creating individual values for the states we can make them alot cleaner and
  turn them into an object. the same goes with the errors. So when creating a custom hook for validation we should create a
  object that has properties that correlate to the values that are in our form. so if we have a form that has inputs like
  date,name,age and lastname. We would use the useState to create a values object that has the properties of date, name, age and
  lastname. Then we would use another useState hook to create an error state and that would mirror the properties that are
  on the other useState function.
  -then we create the most important funciton that we have when creating a form, that is the function that is called when the
  onChange method is called. We create the handleChange funtion, the only parameter is takes is one and it is the event.
  - inside that function we then use object destructoring to pull the name and value from the target and then we call the
  setValue funciton. setValue({...value,[name]:value}) this will use the spread operator to make sure we add the new name and
  value to the state and not completly delete the old state. We will add the [name]:value to the value object, the so the name will
  be what we have set for that current input, make sure that the name value is the same as the property name in the value object
  the value will be what is typed in the input.
  - so we will create somethign like this

            const handleChange = (event)=>{
              const{name,value} = event.target
              setValues({...values,[name]:value})
            }
  - the creation of the handleChange function will make the inputs a controlled component and that is needed for React forms

  - so then we have the handleSubmit function, this will get ran everytime that a form is submitted. the first thing that we
  need to do on this function is to call preventDefault(), this will prevent the form from automatically submitting
  - then we call the serError hook, this is the one that we created right after the values hook. so we call set error, but
  we give it a function as a parameter and that funciton is given the values object.
  - the function that we give the setErrors function is called validate login, the premise of that is pretty simple too, all
  it does is return an object that will contain the errors that we have and that object is then used with the call of setErrors
  - the validateLogin function is defined seperatly in a different file to promote an module code base. it takes a parameter
  called value and that is actually just the values object that we have created in our custom hook. So the parameter object
  will be value and that value will contain properties that are the values from the inputs that are on the form.
  - in the validateLogin we check all those properties on the value object to see if they meet our standard. if they do not then
  we add to the error object that will be returned.
  -so if the values.password is less than 10 characters in length it we will add to the error.password:'password too short'
  and that will be in the returned error object. We do this for every property that is added on the values object.
  - so that should be everything, then on the customHook called Useform we return, the values object, the errors object and the
  handleChange and handleSubmit function.


CREATING THE CUSTOM HOOK:
  - we have created the values and error hooks, then we need to create the handleChange and handleSubmit functions
  - when we create the handleChange funciton we need to make sure that the name we get is the same as the name that we
  have put in the value object.
  - then we call the setValue function and use the spread operator to make sure we dont overwrite the old vlaues.
      setValues({...values,[name]:value})
  - so I think that is everything for the handleChagne function, we can then move on to the handleSubmit function and we pass it two
  parameters, the parameters will be event and a function called validate login. we will use event to prevent the default action
  -we will use the validateLogin function and pass it into the setErrors hook, the validate funciton will be called with the values
  obect and return an errors object. This errors object will be used by setErrors to update the errors object.
  - we have created all of the checks that we are going to run, if any of them fail, they will add to the errors object that will
  be returned from the ValidateLogin function and used by the setErrors function.

  - so now that the custom hook is created we import it to the form component
  - we import it to the component and use obejct destructoring from the funciton that is ran with the parameter of validate function
  - we get the values,errors, handleChange and handleSubmit. the values will be put in the value place of the input so we can
  have a controlled input.
  - the errors object will be put under the respected inputs, if there is no errror than nothing will show. handleChange and
  handleSubmit will be put in their respected positions

  - now we are adding a stage called is submitting
  - this is done with the useEffect hook, through this we are checking to see if the errors object is empty, if it
  is then we are going to rend the request, if it is not, then we are going to do nothing.

  - so the first thing that we are going to do for the submitting stage is create a state called is submitting and set
  the inital value to false but when the handleSubmit function is called we change the value to true.
  - then we use the useEffect hook. we will put the errors object in its dependency array this means that it will get called
  any time that the errors object gets called. Initialy we will have the error object empty with no properties.
  - to check to see if the errors object is empyt we will use Object.keys(errors).length, this will strip all of
  the keys off the object and put them into an array, if there are no keys, then the length will be 0.
  - we want the errors array to be zero so that we can send a request to the backend.
  - we made the errors object initial empty this is ok, because the validatLogin funciton will repopulate the object if there
  is any errors.

  - so the first thing that we do is import the useEffect hook, then we turn the errors object to an empty object, initialy
  - then we use the useEffect hook and put the errors object in the dependency arrray. The next step is to create a new state
  called is submitting and set the inital value to false, this will get turned to true when we fire the handleSubmit function

  - in the useEffect function we need to check if the errors object is empty, we will do this by doing
  Object.keys(errors).length === 0 this will see if the errors object is empty or not, the we will also check is isSubmitting
  is false or true, we want it to be true, this will just be done with a && operator, the the whole thing will work like this
          Object.keys(errors).length ===0 && isSubmitting{
            sendRequest()
          }
 - so this is checking to see if the errors object is empty and if isSubmitting set to True. If both of these conditions are met
 then we will send the request to the backend. in our program this will be a fetch request. For right now we are going to only send
 the userName and the password.

SENDING THE POST REQUEST:
  - so this has me a little confused but I am just going to send a post request with fetch and see what happens.
  - The post request needs to be to v1/signup. so that means we make the fetch call to that endpoint

  - A Requets instance represents the request piece of fetch call. By passing fetch a
  - the bodyParser object exposes various factories to create middlewares. All middlewares will polute the req.body
  property with the parsed body when the Content-Type request header matches the type option, or an empty object
  if there is no body to parse, the Content-type was not matched or an error occured.
  - so my body is empty that means that I could have one of three problems, there is no body to parse, the
  Content-Type was not matched or an error occured
  - I think my problem is probably the content-type in the request header

  bodyParser.json([options]) returns middleware that only parses json and looks at the requests where the content-Type header
  matches the type option.
  - a new body object containing the parsed data is populated on the request object after the middleware
  (ie, req.body)

  bodyParser.urlencoded([options])
  - Returns middleware that only parses urlencoded bodies and only looks at requests where the Content-Type header
  matches the type option. This parser accepts only UTF-8 encoding of the body and supports automatic inflation of
  gzip and deflate encodings
  - a new body object containing the parsed data is populated on the request object after the middleware
  req.body. This object will contain key-value pairs, where the value can be a string or array
  when extended is false, or any type (when extended is true).
  - our extended is set to true so which means that the req.body can be of any type.
  - so I need to read up on the content-type header

  CONTENT-TYPE HEADER:
    -is used to indicate the media type of the resource.
    - in requests like a post, the client tells the server what type of data is actually sent. I think for our
    body-parser we need to set the content-type header to, Content-Type:text/html; charset=UTF-8

    - by default Axios serializes the object to JSON using the JSON.stringify() funciton, if the second
    parameter is an object, then axios also sets the content-type header to applciation/json
    - I have decieded to read more on the API stuff

  EXPRESS API:
  - the fundamentals of an express api are pretty basic, they take a request, parse it and respond
  with a JSON object and an HTTP status code. we will use middleware and routing to take requests and parse
  them, and youll use Express's convience to respond to requests
  - so we will use middleware to parse the incoming data and then we will use express to make the response
  to the request
  -so I finally fixed it, turns out that axios automatically puts everything into a json content header and
  we just have to set the bodyParser to JSON like this bodyParser.json() this will allow us to accept axios's
  JSON data.

  - so the dependency array is yelling at me for not having the right things inside of it. so lets read up on that

  USEEFFECT API:
    - if we use the array optimization, we should make sure that it includes all the values from the component
    scope(such as props and state) that change over time and that are used by the effect. if we don't include
    everything in the dependency array then we will be referencing stale values from previous renders.


MONGOOSE:
  - we can use a low-level friver fro MongoDB but what we really want to use is an object document mapper (ODM).
  the offically supported ODM for MongoDB is mongoose
  - mongoose attempts to strike a balance. it introduces schemas and models, it is what will give our database some
  structure.
  - the mongoose findOne function returns an instance of Mongoose's query class. The query class represents a raw CRUD
  operation that you may send to MongoDB. it provides a chainable interface for building up more sophisticated
  queries
  - a mongoose query is a thenable, meaning that they can have a then() funciton. this means that we can use the
  .then() and the catch() method. so we can go Model.find().then().catch()

STORING THE PASSWORD:
  - so to keep the passwords safe, we will apply a one-way hash to it using the brypt algorithm
  - once we have defined our schema, we will define a pre-save action. Before we save our model to the database
  we will run that code and it will hash the password
  - ok so I think I have everything set up, now the only thing I have to do is run the function to see if it works

  - I have ran into an error where nothing is working, I think that It is happening due to something on the
  client end. that was weird because now everything is working again. very strange.

  - so now that we have that figured out we should be able to just submit the data and see what happens. I forgot
  that I needed to call .save on the new model

  -our new problem is that the request gets sent but there is no response 
